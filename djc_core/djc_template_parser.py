# OVERRIDES START HERE
# We want our `compile_tag` to use `exec()`, so it can return a pre-compiled function.
from typing import Any, Callable, List, Protocol, Tuple, TypeVar, Union
from .djc_core import Tag, TagAttr, compile_ast_to_string

TContext = TypeVar("TContext")


class CompiledFunc(Protocol[TContext]):
    def __call__(
        self,
        context: TContext,
        *,
        variable: Callable[[TContext, str], Any],
        expression: Callable[[TContext, str], Any],
        translation: Callable[[TContext, str], Any],
        filter: Callable[[TContext, str, Any, Any], Any],
    ) -> Tuple[List[Any], List[Tuple[str, Any]]]: ...

    """
    The result of compiling the template tag AST into a Python function.

    This function accepts the context object, and function implementations,
    and returns a tuple of arguments and keyword arguments.

    Example:

    ```python
    tag_ast = parse_tag('...[val1] [1, 2, 3] a=b data={"key": "value"}')
    compiled_func = compile_tag(tag_ast)

    context = {"val1": "foo", "b": "bar"}
    variable = lambda ctx, var: ctx.get(var)
    expression = lambda ctx, expr: f"EXPRESSION_RESOLVED:{expr}"
    translation = lambda ctx, text: f"TRANSLATION_RESOLVED:{text}"
    filter = lambda ctx, name, value, arg=None: f"{value}|{name}:{arg}"

    args, kwargs = compiled_func(
        context,
        variable=variable,
        expression=expression,
        translation=translation,
        filter=filter,
    )

    print(args) # ['foo', [1, 2, 3]]
    print(kwargs) # [('a', 'bar'), ('data', {'key': 'value'})]
    ```
    """


def compile_tag(tag_or_attrs: Union[Tag, List[TagAttr]]):
    """
    Compile the template tag AST (`Tag` object or list of `TagAttr` objects generated by `parse_tag`)
    into a Python function.

    The generated function takes a `context` object and returns a tuple of arguments and keyword arguments.

    Args:
        tag_or_attrs: A `Tag` object from `parse_tag` or a list of `TagAttr` objects.

    Returns:
        A callable function that matches the `CompiledFunc` protocol.

    """
    if isinstance(tag_or_attrs, Tag):
        attributes = tag_or_attrs.attrs
    else:
        attributes = tag_or_attrs
    func_string = compile_ast_to_string(attributes)
    local_scope = {}
    exec(func_string, {}, local_scope)

    compiled_func = local_scope["compiled_func"]
    compiled_func._source_code = func_string
    return compiled_func
